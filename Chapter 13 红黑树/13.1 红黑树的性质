# 红黑树

# 出现原因：一棵高度为 h 的二叉搜索树，其查询和修改操作的时间复杂度均为 O(h)。因此，如果搜索树的高度较低时，这些集合操作会执行的很快；但如果树的高度较高时，
#          这些集合操作可能并不比在链表上执行得快。
#          “红黑树” 是 “平衡搜索树” 的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为 O(lgn)。


# 红黑树定义：（1）红黑树是一棵二叉搜索树；
#            （2）每个结点上增加了一个存储位来表示结点的颜色（红色 或 黑色），即树中每个结点包含 5 个属性：color、key、left、right 和 parent；
#            （3）通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出 2 倍，因而是近似于平衡的；
#            （4）如果一个结点没有子结点或父结点，则该结点相应指针属性的值为 None。我们可将这些 None 视为指向二叉搜索树的叶结点（外部结点）的指针，
#                 而把带关键字的结点视为树的内部结点。


# 红黑树的 “红黑” 性质：
#（1）每个结点或是红色的，或是黑色的；
#（2）根结点是黑色的；
#（3）每个叶结点 (None) 是黑色的；
#（4）如果一个结点是红色的，则它的两个两个子结点都是黑色的；
#（5）对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。


# 黑高：从某个结点 x 出发（不含该结点）到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高，记为 bh(x)。
#       根据性质 (5)，从某结点出发的所有下降到其叶结点的简单路径的黑结点个数都相同，所以，
#       红黑树的黑高为其根结点的黑高。


# 为什么红黑树是一种好的搜索树？
# 答：查询（Search、Minimum、Maximum、Successor 和 Precessor）可在红黑树上在 O(lgn) 时间内执行。
#    （因为这些操作在一棵高度为 h 的二叉搜索树上的运行时间为 O(h)，而任何包含 n 个结点的红黑树都是高度为 O(lgn) 的二叉搜索树。详见下文引理证明。）


# 引理：一棵有 n 个内部结点的红黑树的高度至多为 2lg(n+1)。
# 证明：（1）先证明以任一结点 x 为根的子树中至少包含 2^(bh(x)) - 1 个内部结点。  方法：归纳法
#           基本情况：如果 x 的高度为 0，则 x 必为叶结点 None，且以 x 为根结点的子树至少包含 2^(bh(x)) - 1 = 2^0 - 1 = 0 个内部结点；
#           归纳：考虑一个高度为正值且有两个子结点的内部结点 x，每个子结点有黑高 bh(x) 或 bh(x) - 1，其分别取决于自身的颜色是红还是黑。
#                 由于 x 子结点的高度比 x 本身的高度要低，可以利用归纳假设得出每个子结点至少有 2^(bh(x)-1) - 1 个内部结点，所以，
#                 以 x 为根的子树至少包含 (2^(bh(x)-1) - 1) + (2^(bh(x)-1) - 1) + 1 = 2^(bh(x)) - 1 个内部结点，得证。

#      （2）设 h 为树的高度，根据性质 (4)，从根到叶结点（不包括根结点）的任何一条简单路径上都至少有一半的结点为黑色。因此根的黑高至少为 h/2，于是有：
#           n >= 2^(h/2) - 1  ==>  h <= 2lg(n+1)



# 习题 13.1-6：在一棵黑高为 k 的红黑树中，内部结点最多可能有多少个？最少可能有多少个？
# 答：因为黑高包含最底层的黑色 NIL 的高度，所以内部结点最多情况下是红黑相交，1 + 2 + 4 + ... + 2^(2k-1) = 2^(2k) - 1 个
#                                                  最少情况下全树只有黑色结点，1 + 2 + ... + 2^(k-1) = 2^k - 1 个


# 计数排序

# 前提条件：假设 n 个输入元素中的每一个都是在 0 到 k 区间内的一个整数，其中 k 为某个整数。
# 基本思想：对每一个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放到它在输出数组中的位置上了。
# 重要性质：计数排序是稳定的（即具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同）

# 输入：数组 A[1...n], B[1...n] 存放排序的输出，C[0...k] 提供临时存储空间。

# 计数排序总的时间代价就是θ(k+n)，在实际工作中，当 k = O(n) 时，一般会采用计数排序，排序的运行时间为θ(n)
def CountingSort(A, k):

  B = [0] * len(A)
  C = [0] * (k+1)
  
  # 初始化，数组 C 中的值全被置为 0，时间复杂度为θ(k)
  for i in range(0, k+1):
    C[i] = 0
  
  # 遍历 A 中的每一个元素，统计每个元素的数量，时间复杂度为θ(n)
  for j in range(0, len(A)):
    C[A[j]] = C[A[j]] + 1
  
  # C[i] 中保存的是小于等于 i 元素的个数，时间复杂度为θ(k)
  for i in range(1, k+1):
    C[i] = C[i] + C[i-1]
  
  # 把每个元素 A[j] 放到它在输出数组 B 中的正确位置上，由于Python下标从0开始，所以此处是 C[A[j]]-1，时间复杂度为θ(n)
  # 倒序遍历 A 的原因是为了确保排序算法是稳定的
  for j in range(len(A)-1, -1, -1):
    B[C[A[j]]-1] = A[j]
    C[A[j]] -= 1
  
  return B

alist = [2, 5, 3, 0, 2, 3, 0, 3]
print(CountingSort(alist, 5))

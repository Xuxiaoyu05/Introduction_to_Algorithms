# 基数排序

# 基本思想：按最低有效位进行排序来解决卡片排序问题，重复这一过程，直到对所有的 d 位数字都进行了排序。所以，对一叠卡片的排序仅需要进行 d 轮。
#          基数排序是稳定排序。而为了确保基数排序的稳定性，一位数排序算法必须是稳定的。但是基数排序不是稳定排序。

# 假设 n 个 d 位的元素存放在数组 A 中，其中第 1 位是最低位，第 d 位是最高位。

def RadixSort(A, d):
#   for i = 1 to d:
#     use a stable sort to sort array A on digit A

    
# 引理 8.3：给定 n 个 d 位数，其中每一个数位有 k 个可能的取值。如果 RadixSort 使用的稳定排序方法耗时 θ(n+k)，那么它就可以在 θ(d(n+k)) 时间内将这些数
#          排好序。当 d 为常数且 k = O(n) 时，基数排序具有线性的时间代价。

# 在更一般的情况中，我们可以灵活地决定如何将每个关键字分解成若干位。给定 n 个 b 位数和任何正整数 r <= b，如果 RadixSort 使用的稳定排序算法对数据取值区间
# 是 0 到 k 的输入进行排序耗时 θ(n+k)，那么它就可以在 θ(b/r(n+2^r)) 时间内将这些数排好序。
# 证明：对于一个值 r <= b，每个关键字都可以看做 d = ceil(b/r) 个 r 位数，每个数都是在 0 到 2^r - 1 区间内的一个整数。如果 b < floor(lgn)，显然，选择
#       r = b 得到的时间代价为 θ(n)，这一结果是渐进上最优的。如果 b >= ceil(lgn)，选择 r = floor(lgn)，得到的运行时间为 θ(bn/lgn)。

1. 比较排序算法：在排序的最终结果中，各元素的次序依赖于它们之间的比较，这类排序算法称为比较排序。如插入排序，归并排序，堆排序，快速排序等。

2. 比较排序可以被抽象为一棵决策树，决策树是一棵二叉树。排序算法的执行对应于一条从树的根结点到叶结点的路径，每一个内部结点表示一次比较，当到达一个叶结点时，
   表示排序算法已经确定了一个顺序。对于一个正确的比较排序算法来说，n 个元素的 n! 种可能的排列都应该出现在决策树的叶结点，而且每一个叶结点都必须是可以从
   根结点经由某条路径到达的。

3. 比较排序算法的下界：在决策树中，从根结点到任意一个可达叶结点之间最长简单路径的长度，表示的是排序算法中最坏情况下的比较次数。因此，一个比较排序算法中的
                     最坏情况比较次数 = 决策树的高度。

定理8.1：对包含 n 个元素的输入序列来说，在最坏情况下，任何比较排序算法都要经过 Ω(nlgn) 次比较。
证明：考虑一棵高度为 h，具有 l 个可达叶结点的决策树。  n! <= l <= 2^h  ==> h >= lg(n!) = Ω(nlgn) 

推论8.2：堆排序和归并排序都是渐进最优的比较排序算法。
证明：堆排序和归并排序的运行时间上界为 O(nlgn)


习题8.1-1：在一棵比较排序算法的决策树中，一个叶结点可能的最小深度是多少？

习题8.1-2：不使用斯特林近似公式，给出 lg(n!) 的渐进紧确界，即求累加和 ∑lgk (k=1...n)。

习题8.1-3：证明：对 n！种长度为 n 的输入中的至少一半，不存在能达到线性运行时间的比较排序算法。如果只要求对 1/n 的输入达到线性时间呢？1/2^n呢？

习题8.1-4：假设现有一个包含 n 个元素的待排序序列。该序列由 n/k 个子序列组成，每个子序列包含 k 个元素。一个给定子序列中的每个元素都小于其后继子序列中的
          所有元素，且大于其前驱子序列中的每个元素。因此，对于这个长度为 n 的序列的排序转化为对 n/k 个子序列中的 k 个元素的排序。试证明：这个排序问题中
          所需比较次数的下界是 Ω(nlgk)。（提示：简单地将每个子序列的下界进行合并是不严谨的）
          


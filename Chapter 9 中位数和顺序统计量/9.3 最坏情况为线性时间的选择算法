# 一个最坏情况运行时间为 O(n) 的选择算法

# 目标：算法 Select 可以确定一个有 n > 1 个不同元素的输入数组中第 i 小的元素。（如果 n = 1，则 Select 只返回它的唯一输入数值作为第 i 小的元素）

# 基本思想：Select 用的也是快速排序的划分算法 Partition，但做了修改，把划分的主元也作为输入参数

# 基本步骤：
# （1）将输入数组的 n 个元素划分为 ⌈n/5⌉ 组，每组 5 个元素，且至多只有一组由剩下的 n%5 个元素组成；
# （2）寻找这 ⌈n/5⌉ 组中每一组的中位数，首先对每组元素进行插入排序，然后确定每组有序元素的中位数；
# （3）对第 2 步找出的 ⌈n/5⌉ 个中位数，递归调用 Select 以找出其中位数 x； （如果有偶数个中位数，为了方便，约定 x 是较小的中位数）
# （4）利用修改过的 Partition 版本，按中位数的中位数 x 对输入数组进行划分。让 k 比划分的低区中的元素数目多 1，因此 x 是第 k 小的元素，并且有 n-k 个元素
#      在划分的高区；
# （5）如果 i = k，则返回 x。如果 i < k，则在低区递归调用 Select 来找出第 i 小的元素。如果 i > k，则在高区递归查找第 i-k 小的元素。

# T(n) <= T(⌈n/5⌉) + T(7n/10+6) + O(n)  若 n >= 140(可以用任何严格大于70的整数来替换它)

# 习题9.3-1：在算法 Select 中，输入元素被分为每组 5 个元素。如果它们被分为每组 7 个元素，该算法仍然会是线性时间吗？ 答：是
#                                                        如果分为每组 3 个元素，该算法仍然会是线性时间吗？ 答：不是


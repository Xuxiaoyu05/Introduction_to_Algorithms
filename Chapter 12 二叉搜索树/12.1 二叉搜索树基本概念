# 二叉搜索树

# 基本概念：（1）一棵二叉搜索树是以一棵二叉树来组织的，每个结点除了 key 和卫星数据之外，每个结点还包含属性 left（左孩子）、right（右孩子） 和 p（双亲）。
#               如果某个孩子结点和父结点不存在，则相应属性的值为 None。根结点是树中唯一父指针为 None 的结点。
#          （2）二叉搜索树，对任何结点 x，其左子树中的关键字最大不超过 x.key，其右子树中的关键字最小不低于 x.key。

# 大部分搜索树操作的最坏运行时间与树的高度成正比。对于有 n 个结点的一棵 “完全二叉树” 来说，这些操作的最坏运行时间为 θ(lgn)。

# 重要性质：中序遍历二叉搜索树可以按序输出二叉搜索树中的所有关键字。

# 三种遍历方式：
# （1）先序遍历：输出的子树根的关键字在其左右子树的关键字之前；
# （2）中序遍历：输出的子树根的关键字位于其左子树和右子树的关键字值之间；
# （3）后序遍历：输出的子树根的关键字在其左右子树的关键字之后。


# 二叉搜索树中序遍历的递归解法，时间复杂度为θ(n) 
def InOrder_Tree(root):
  if root != None:
    InOrder_Tree(root.left)
    print(root.val)
    InOrder_Tree(root.right)
    
# 定理：如果 root 是一棵有 n 个结点子树的根，那么调用 InOrder_Tree 需要 θ(n) 时间。[即遍历一棵有 n 个结点的二叉搜索树需要耗费 θ(n) 的时间]

# 证明：
#     由于 InOrder_Tree 要访问这棵子树的全部 n 个结点，所以有 T(n) = Ω(n)，下面需要证明 T(n) = O(n)。
#    （1）基本情况：对于一棵空树，InOrder_Tree 需要耗费一个小的常数时间（判断 root != None），因此对某个常数 c > 0，有 T(0) = c
#    （2）对 n > 0，假设调用 InOrder_Tree 作用在一个结点 x 上， x 结点左子树有 k 个结点且右子树有 n-k-1 个结点。
#         则 T(n) <= T(k) + T(n-k-1) + d，其中 d > 0。
#         使用替换法，证明 T(n) <= (c+d)n + c，可以证得 T(n) = O(n)。
#         T(n) <= T(k) + T(n-k-1) + d = (c+d)k + c + (c+d)(n-k-1) + c + d = (c+d)n + c
#         完成证明。
